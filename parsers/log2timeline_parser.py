#!/usr/bin/env python3
"""
Parser for log2timeline (Plaso)
"""

import os
import json
import subprocess
import sys
import tempfile
import shutil
import time
import glob
from datetime import datetime
from typing import Optional


class Log2TimelineParser:
    """Class to parse files with log2timeline (Plaso)"""

    def __init__(self, log2timeline_path: str = "log2timeline.py", psort_path: str = "psort.py"):
        """
        Initialize the log2timeline parser

        Args:
            log2timeline_path: Path to log2timeline.py
            psort_path: Path to psort.py
        """
        self.log2timeline_path = log2timeline_path
        self.psort_path = psort_path

    @staticmethod
    def safe_rmtree(path: str, max_attempts: int = 5) -> bool:
        """
        Safely remove a directory with multiple attempts

        Args:
            path: Path to the directory to remove
            max_attempts: Maximum number of attempts

        Returns:
            True if successful, False otherwise
        """
        for attempt in range(max_attempts):
            try:
                if os.path.exists(path):
                    shutil.rmtree(path)
                return True
            except (PermissionError, OSError) as e:
                if attempt < max_attempts - 1:
                    time.sleep(0.5)
                else:
                    print(f"    Warning: Unable to remove {path}: {e}")
                    return False
        return False

    @staticmethod
    def cleanup_log2timeline_logs(base_dir: str = ".") -> None:
        """
        Clean up log files generated by log2timeline and psort

        Args:
            base_dir: Directory to search for logs
        """
        log_patterns = [
            "log2timeline-*.log.gz",
            "psort-*.log.gz",
            "Worker_*_log2timeline-*.log.gz"
        ]

        cleaned_count = 0
        for pattern in log_patterns:
            log_files = glob.glob(os.path.join(base_dir, pattern))
            for log_file in log_files:
                try:
                    os.remove(log_file)
                    cleaned_count += 1
                except Exception as e:
                    print(f"    Warning: Unable to remove {log_file}: {e}")

        if cleaned_count > 0:
            print(f"    {cleaned_count} log file(s) cleaned")

    @staticmethod
    def convert_plaso_to_jsonl(json_line_file: str, output_jsonl: str, platform: str = "elk") -> int:
        """
        Convert psort JSON-line to ELK or Timesketch compatible format

        Args:
            json_line_file: JSON-line file generated by psort
            output_jsonl: Output file
            platform: Target platform ("elk" or "timesketch")

        Returns:
            Number of entries converted
        """
        entries = []

        try:
            with open(json_line_file, 'r', encoding='utf-8', errors='ignore') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line:
                        continue

                    try:
                        plaso_entry = json.loads(line)

                        # Convert Plaso entry to standard format
                        entry = {}

                        # Timestamp - Plaso uses microseconds since epoch
                        if 'timestamp' in plaso_entry:
                            try:
                                # Plaso timestamp is in microseconds
                                timestamp_sec = plaso_entry['timestamp'] / 1000000.0
                                dt = datetime.utcfromtimestamp(timestamp_sec)
                                iso_timestamp = dt.isoformat() + 'Z'
                            except:
                                iso_timestamp = datetime.now().isoformat() + 'Z'
                        else:
                            iso_timestamp = datetime.now().isoformat() + 'Z'

                        if platform == "elk":
                            entry['@timestamp'] = iso_timestamp
                        elif platform == "timesketch":
                            entry['datetime'] = iso_timestamp
                            entry['timestamp_desc'] = plaso_entry.get('timestamp_desc', 'Event Time')

                        # Message
                        if 'message' in plaso_entry:
                            entry['message'] = plaso_entry['message']
                        elif 'display_name' in plaso_entry:
                            entry['message'] = plaso_entry['display_name']

                        # Copy other fields
                        for key, value in plaso_entry.items():
                            if key not in ['timestamp', 'message', 'datetime', 'timestamp_desc']:
                                # Clean field names
                                clean_key = str(key).replace(' ', '_').replace('/', '_').replace('\\', '_').lower()
                                entry[clean_key] = value

                        # Metadata
                        entry['log_type'] = 'plaso'
                        entry['parser'] = 'log2timeline'

                        entries.append(entry)

                    except json.JSONDecodeError as e:
                        print(f"    Warning: JSON error on line {line_num}: {e}")
                        continue

            # Save converted entries
            with open(output_jsonl, 'w', encoding='utf-8') as f:
                for entry in entries:
                    f.write(json.dumps(entry, ensure_ascii=False) + '\n')

            return len(entries)

        except Exception as e:
            print(f"    Error: Plaso conversion failed: {e}")
            import traceback
            traceback.print_exc()
            return 0

    def parse_directory(self, source_dir: str, output_json_path: str, platform: str = "elk",
                        case_name: str = "unknown") -> bool:
        """
        Parse a directory with log2timeline and convert to JSON/JSONL

        Args:
            source_dir: Source directory to parse
            output_json_path: Path to the output JSON file
            platform: Target platform ("elk" or "timesketch")
            case_name: Case name

        Returns:
            True if successful, False otherwise
        """
        print(f"\nParsing with log2timeline: {source_dir}")

        if not os.path.exists(source_dir):
            print(f"    Error: Source directory not found: {source_dir}")
            return False

        # Create a temporary directory for Plaso files
        temp_dir = tempfile.mkdtemp(prefix="plaso_")
        plaso_file = os.path.join(temp_dir, f"{case_name}.plaso")
        temp_jsonl = os.path.join(temp_dir, f"{case_name}_plaso.jsonl")

        try:
            # Step 1: Run log2timeline to create the .plaso file
            print(f"    Phase 1: Creating Plaso file...")

            # Command as specified
            log2timeline_cmd = [
                self.log2timeline_path,
                source_dir,
                '--status_view', 'none',
                '--storage_file', plaso_file
            ]

            print(f"    Command: {' '.join(log2timeline_cmd[:3])}... {source_dir}")

            try:
                result = subprocess.run(
                    log2timeline_cmd,
                    capture_output=True,
                    text=True,
                    timeout=1800  # 30 minutes max
                )

                if result.returncode != 0:
                    print(f"    Error: log2timeline failed (code {result.returncode})")
                    if result.stderr:
                        # Display only first significant error lines
                        error_lines = result.stderr.split('\n')
                        for line in error_lines[:10]:
                            if line.strip() and not line.startswith('plaso'):
                                print(f"       {line}")
                    return False

                print(f"    Plaso file created")

            except subprocess.TimeoutExpired:
                print(f"    Error: Timeout during log2timeline execution (>30min)")
                return False
            except FileNotFoundError:
                print(f"    Error: log2timeline.py not found. Install Plaso.")
                print(f"       pip install plaso-tools")
                return False

            # Verify that the Plaso file was created
            if not os.path.exists(plaso_file):
                print(f"    Error: Plaso file not created")
                return False

            # Step 2: Export with psort to JSON-line
            print(f"    Phase 2: Exporting to JSON...")

            psort_cmd = [
                self.psort_path,
                '-o', 'json_line',
                '-w', temp_jsonl,
                plaso_file
            ]

            print(f"    Command: {' '.join(psort_cmd[:4])}...")

            try:
                result = subprocess.run(
                    psort_cmd,
                    capture_output=True,
                    text=True,
                    timeout=600  # 10 minutes max
                )

                if result.returncode != 0:
                    print(f"    Error: psort failed (code {result.returncode})")
                    if result.stderr:
                        error_lines = result.stderr.split('\n')
                        for line in error_lines[:10]:
                            if line.strip():
                                print(f"       {line}")
                    return False

                print(f"    JSON export complete")

            except subprocess.TimeoutExpired:
                print(f"    Error: Timeout during psort execution (>10min)")
                return False
            except FileNotFoundError:
                print(f"    Error: psort.py not found. Install Plaso.")
                return False

            # Verify that the JSON file was created
            if not os.path.exists(temp_jsonl):
                print(f"    Error: JSON file not created")
                return False

            # Step 3: Convert for ELK if necessary
            print(f"    Phase 3: Converting to final format...")

            if platform == "timesketch":
                # For Timesketch, copy the file directly
                shutil.copy(temp_jsonl, output_json_path)

                # Count lines
                with open(output_json_path, 'r') as f:
                    entry_count = sum(1 for line in f if line.strip())

                print(f"    {entry_count} entries exported -> {os.path.basename(output_json_path)}")

            else:
                # For ELK, convert the format
                entry_count = self.convert_plaso_to_jsonl(temp_jsonl, output_json_path, platform)

                if entry_count == 0:
                    print(f"    Error: No entries converted")
                    return False

                print(f"    {entry_count} entries converted -> {os.path.basename(output_json_path)}")

            # Clean up log2timeline/psort logs in the current directory
            self.cleanup_log2timeline_logs()

            return True

        except Exception as e:
            print(f"    Error: Unexpected error: {e}")
            import traceback
            traceback.print_exc()
            return False

        finally:
            # Clean up temporary directory
            self.safe_rmtree(temp_dir)